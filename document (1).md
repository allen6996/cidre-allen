# cidre-allen## pandas cleaningimport pandas as pddf=pd.read_csv('data.csv') -took the datasetfill_avg=df.fillna(df.mean()) -filled missing data with mean of the columnsum_avg=fill_avg.mean() -gives summary of average marks&nbsp;print("Cleaned data:") - printing the valuesprint(fill_avg)print("Average of the cleaned data:")print(sum_avg)##exceptiondef process_excel(file_path,col):&nbsp; &nbsp; error_data=[] - initialized 2 lists&nbsp; &nbsp; data=[]&nbsp; &nbsp; for i in os.listdir(file_path): -checks each file in directory using os&nbsp; &nbsp; &nbsp; &nbsp; if i.endswith('.xlsx'): -finds excell extention files&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; df = pd.read_excel(file_path) -reads data&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; df_data = df[col]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data.append(df_data)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; except Exception as e:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error_data.append(f"Error in {i}: {e}") -appends error data into the list&nbsp; &nbsp; return error_data -returns the error list---##time-complexitiyarr = [i for i in range(100000)] -takes list of 1 million numberstarget=2 - set a targets=set() - set function is used as it doesnt keep duplicatesfor i in arr: -checks from 0 to 1 million&nbsp; &nbsp; if target - i in s:&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; print("Pair found:", i, target - i)&nbsp; &nbsp; &nbsp; &nbsp; break&nbsp; &nbsp; s.add(i) -if not found, added to set---##oopsclass Book: -made class for books&nbsp; &nbsp; def __init__(self, title,author,availablility_status):&nbsp; &nbsp; &nbsp; &nbsp; self.title = title&nbsp; &nbsp; &nbsp; &nbsp; self.author = author&nbsp; &nbsp; &nbsp; &nbsp; self.availablility_status = availablility_status&nbsp; &nbsp; def borrow(self): -gave two functions for returning and borrowing&nbsp; &nbsp; &nbsp; &nbsp; if self.availablility_status:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.availablility_status = False&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print("You borrowed '{self.title}' by '{self.author}'")&nbsp; &nbsp; &nbsp; &nbsp; else:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print("'{self.title}' is currently not available.")&nbsp; &nbsp; def return_b(self):&nbsp; &nbsp; &nbsp; &nbsp; self.availablility_status = True&nbsp; &nbsp; &nbsp; &nbsp; print("You returned '{self.title}' by '{self.author}'")class Library: -made a class for library&nbsp; &nbsp; def __init__(self):&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; self.books = []&nbsp; &nbsp; def add(self, book):&nbsp; &nbsp; &nbsp; &nbsp; self.books.append(book)&nbsp; &nbsp; def find_b(self, title):&nbsp; &nbsp; &nbsp; &nbsp; for i in self.books:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if i.title == title:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i&nbsp; &nbsp; &nbsp; &nbsp; return None&nbsp; &nbsp;&nbsp;title=input("Enter the book title: ")author=input("Enter the book author: ")obj= Book(title, author, True) -took the input and set availability as true and made an objectlib= Library() -made object for librarylib.add(obj)title= input("Enter the book title to borrow: ") -code to borrow or returnbook = lib.find_b(title)&nbsp;if book:&nbsp; &nbsp; book.borrow()else:&nbsp; &nbsp; print("Book not found in the library.")title= input("Enter the book title to return: ")book = lib.find_b(title)if book:&nbsp; &nbsp; book.return_b()##apiimport pandas as pd -imported neccesery packagesimport requestsimport timeapi_url = "url" -taking the url for apiweather_info = [] -creates an empty listwhile True: -inside loop&nbsp; &nbsp; response = requests.get(api_url) -takes response from utl&nbsp; &nbsp; w_d = response.json() -convert this to python dictionary&nbsp; &nbsp; dic = {'temp': w_d[temp],'humidity': w_d[humidity]} -taking neccesery values ie tempreature and humidity&nbsp; &nbsp; data= pd.DataFrame(dic) -made it as a dataframe&nbsp;&nbsp; &nbsp; weather_info.append([data]) -append to an variable&nbsp; &nbsp; weather_info=weather_info.to_csv("weather_info.csv") -converts and store it in csv&nbsp; &nbsp; time.sleep(3600) -takes value after 1 hour--##parsingwith open('C:/Users/hp/Downloads/sample_logs.txt') as file: -opens file&nbsp; &nbsp; for i in file: -checks all file&nbsp; &nbsp; &nbsp; &nbsp; if 'ERROR' in i: -if 'error' in line prints the line&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(i)&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;